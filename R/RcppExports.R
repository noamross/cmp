# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute COM-Poisson Normalizing Constant
#'
#' Computes the normalizing constant in the COM-Poisson model for given values
#' of the parameters.
#'
#' \code{compute_z} computes the COM-Poisson normalizing constant \deqn{
#' }{z = Sum (lambda^j)/(j!^nu) }\deqn{ z = \sum_{i=0}^\infty
#' \frac{\lambda^j}{(j!)^\nu} }{z = Sum (lambda^j)/(j!^nu) }\deqn{ }{z = Sum
#' (lambda^j)/(j!^nu) } to the specified precision. If no precision is
#' specified, then the package default is used.
#'
#' \code{compute_log_z} is equivalent to \code{log(compute_z(lambda,
#' nu))} but provudes additional precision.
#'
#' @aliases compute_z compute_log_z
#' @param lambda Lambda value in COM-Poisson distribution
#' @param nu Nu value in CMP distribution
#' @param log.error Precision in the log of the normalizing constant
#' @return The normalizing constant as a real number with specified precision.
#' @author Jeffrey Dunn
#' @seealso \code{\link{com_fit}}
#' @references Shmueli, G., Minka, T. P., Kadane, J. B., Borle, S. and
#' Boatwright, P., \dQuote{A useful distribution for fitting discrete data:
#' Revival of the Conway-Maxwell-Poisson distribution,} J. Royal Statist. Soc.,
#' v54, pp. 127-142, 2005.
#' @keywords models
#' @examples
#'
#' data(insurance)
#' fit = cmp_fit(Lemaire)
#' z = compute_z(fit$lambda, fit$nu)
#'
#' @export
compute_z <- function(lambda, nu, log_error_z = 1e-6, maxit_z = 10000L) {
    .Call('cmp_compute_z', PACKAGE = 'cmp', lambda, nu, log_error_z, maxit_z)
}

#' @export
compute_log_z <- function(lambda, nu, log_error_z = 1e-6, maxit_z = 10000L) {
    .Call('cmp_compute_log_z', PACKAGE = 'cmp', lambda, nu, log_error_z, maxit_z)
}

#' @export
compute_log_z_approx <- function(lambda, nu) {
    .Call('cmp_compute_log_z_approx', PACKAGE = 'cmp', lambda, nu)
}

#' @export
logsumexp <- function(x) {
    .Call('cmp_logsumexp', PACKAGE = 'cmp', x)
}

#' @export
logdiffexp <- function(x, y) {
    .Call('cmp_logdiffexp', PACKAGE = 'cmp', x, y)
}

#' @export
compute_log_z_old <- function(lambda, nu, log_error_z = 0.0001, maxit_z = 10000L) {
    .Call('cmp_compute_log_z_old', PACKAGE = 'cmp', lambda, nu, log_error_z, maxit_z)
}

#' The Conway-Maxwell-Poisson Distribution
#'
#' Probability mass function and random generation for the Conway-Maxwell-
#' Poisson Distribution distribution for given values of the parameters.
#'
#' Computes the probability mass function of the CMP distribution
#' \deqn{ }{f(x) = (1/Z) (lambda^x)/(x!^nu).}\deqn{ f(x) =
#' \frac{1}{Z(\lambda,\nu)}\frac{\lambda^x}{(x!)^\nu}. }{f(x) = (1/Z)
#' (lambda^x)/(x!^nu).}\deqn{ }{f(x) = (1/Z) (lambda^x)/(x!^nu).}
#'
#' @aliases dcmp pcmp qcmp rcmp 
#' @param x level to evaluate the PMF at
#' @param lambda value of lambda parameter
#' @param nu value of nu parameter
#' @param z normalizing constant, computed if not specified
#' @param n number of random values to return
#' @param log.z natural log of z
#' @return \code{dcmp} gives the probability that a random CMP variable
#' X takes value x.  \code{rcmp} gives a vector of \code{n} random values
#' sampled from the CMP distribution.
#' @author Jeffrey Dunn
#' @seealso \code{\link{cmp_loglikelihood}},
#' @references Shmueli, G., Minka, T. P., Kadane, J. B., Borle, S. and
#' Boatwright, P., \dQuote{A useful distribution for fitting discrete data:
#' Revival of the Conway-Maxwell-Poisson distribution,} J. Royal Statist. Soc.,
#' v54, pp. 127-142, 2005.
#' @keywords models
#' @export
dcmp <- function(x, lambda, nu, z = as.numeric( c(NA)), log = FALSE, log_error_z = 1e-6, maxit_z = 10000L) {
    .Call('cmp_dcmp', PACKAGE = 'cmp', x, lambda, nu, z, log, log_error_z, maxit_z)
}

#' @rdname dcmp
#' @export
pcmp <- function(q, lambda, nu, z = NA_real_, log = FALSE, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_pcmp', PACKAGE = 'cmp', q, lambda, nu, z, log, log_error_z, maxit_z, parallel)
}

#' @rdname dcmp
#' @export
qcmp <- function(p, lambda, nu, z = NA_real_, log = FALSE, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_qcmp', PACKAGE = 'cmp', p, lambda, nu, z, log, log_error_z, maxit_z, parallel)
}

#' @rdname dcmp
#' @export
rcmp <- function(n, lambda, nu, z = NA_real_, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_rcmp', PACKAGE = 'cmp', n, lambda, nu, z, log_error_z, maxit_z, parallel)
}

#' @export
cmp_loglik <- function(x, lambda, nu, z = as.numeric( c(NA)), log_error_z = 1e-6, maxit_z = 10000L) {
    .Call('cmp_cmp_loglik', PACKAGE = 'cmp', x, lambda, nu, z, log_error_z, maxit_z)
}

#'@export
pois_loglik <- function(x, lambda) {
    .Call('cmp_pois_loglik', PACKAGE = 'cmp', x, lambda)
}

#'@export
nb_loglik <- function(x, mu, size) {
    .Call('cmp_nb_loglik', PACKAGE = 'cmp', x, mu, size)
}

#'@export
pb_loglik <- function(x, size, prob) {
    .Call('cmp_pb_loglik', PACKAGE = 'cmp', x, size, prob)
}

#' @export
cmp_kld <- function(x, lambda, nu, z = as.numeric( c(NA)), log_error_z = 1e-6, maxit_z = 10000L) {
    .Call('cmp_cmp_kld', PACKAGE = 'cmp', x, lambda, nu, z, log_error_z, maxit_z)
}

#'@export
pois_kld <- function(x, lambda) {
    .Call('cmp_pois_kld', PACKAGE = 'cmp', x, lambda)
}

#'@export
nb_kld <- function(x, mu, size) {
    .Call('cmp_nb_kld', PACKAGE = 'cmp', x, mu, size)
}

#' Computes Expectation of a Function of a CMP Random Variable
#'
#' Computes an expectation of a function of a CMP random variable.
#'
#' Computes the expectation \eqn{E[f(X)]}{E[f(X)]} where X is a CMP
#' random variable.
#'
#' @param f function taking as a single argument the value of x
#' @param lambda value of lambda parameter
#' @param nu value of nu parameter
#' @param log.error precision in the log of the expectation
#' @return The expectation as a real number.
#' @author Jeffrey Dunn
#' @seealso \code{\link{cmp_mean}}, \code{\link{cmp_var}},
#' \code{\link{cmp_fit}}
#' @references Shmueli, G., Minka, T. P., Kadane, J. B., Borle, S. and
#' Boatwright, P., \dQuote{A useful distribution for fitting discrete data:
#' Revival of the Conway-Maxwell-Poisson distribution,} J. Royal Statist. Soc.,
#' v54, pp. 127-142, 2005.
#' @keywords models
#' @export
cmp_log_mean <- function(lambda, nu, log_error = 1e-6, maxit = 1e6L, z = NA_real_, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_cmp_log_mean', PACKAGE = 'cmp', lambda, nu, log_error, maxit, z, log_error_z, maxit_z, parallel)
}

#' @export
cmp_log_mean_approx <- function(lambda, nu) {
    .Call('cmp_cmp_log_mean_approx', PACKAGE = 'cmp', lambda, nu)
}

#' @export
cmp_mean <- function(lambda, nu, log_error = 1e-6, maxit = 1e6L, z = NA_real_, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_cmp_mean', PACKAGE = 'cmp', lambda, nu, log_error, maxit, z, log_error_z, maxit_z, parallel)
}

#' @export
cmp_log_var <- function(lambda, nu, log_error = 1e-6, maxit = 1e6L, z = NA_real_, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_cmp_log_var', PACKAGE = 'cmp', lambda, nu, log_error, maxit, z, log_error_z, maxit_z, parallel)
}

#' @export
cmp_var <- function(lambda, nu, log_error = 1e-6, maxit = 1e6L, z = NA_real_, log_error_z = 1e-6, maxit_z = 10000L, parallel = FALSE) {
    .Call('cmp_cmp_var', PACKAGE = 'cmp', lambda, nu, log_error, maxit, z, log_error_z, maxit_z, parallel)
}

#' @export
cmp_log_var_approx <- function(lambda, nu) {
    .Call('cmp_cmp_log_var_approx', PACKAGE = 'cmp', lambda, nu)
}

#' @export
cmp_var_approx <- function(lambda, nu) {
    .Call('cmp_cmp_var_approx', PACKAGE = 'cmp', lambda, nu)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('cmp_RcppExport_registerCCallable', PACKAGE = 'cmp')
})
